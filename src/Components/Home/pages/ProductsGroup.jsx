import React, { useState, useEffect, useCallback } from "react";
import "./ProductsGroup.css"; // Styles specific to this component
import { API_PRODUCT_GROUPS_ENDPOINT } from "../../../config"; // Adjust path if needed

// Simple Modal Component (can be shared or local)
const MessageModal = ({ message, onClose, type = "success" }) => {
  if (!message) return null;
  return (
    <div className="pg-modal-overlay">
      {" "}
      {/* Using pg- prefix */}
      <div className={`pg-modal-content ${type}`}>
        {" "}
        {/* Note: type adds 'success' or 'error' class */}
        <p>{message}</p>
        <button onClick={onClose} className="pg-modal-close-button">
          OK
        </button>
      </div>
    </div>
  );
};

const ProductsGroup = () => {
  const [productGroups, setProductGroups] = useState([]);
  const [newPGroupName, setNewPGroupName] = useState("");

  const [isLoading, setIsLoading] = useState(false); // For fetching list
  const [isSubmitting, setIsSubmitting] = useState(false); // For adding new group
  const [error, setError] = useState(null); // For general fetch/post errors
  const [formError, setFormError] = useState(null); // For form-specific validation errors from backend
  const [successMessage, setSuccessMessage] = useState("");

  // Fetch product groups from the backend
  const fetchProductGroups = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(API_PRODUCT_GROUPS_ENDPOINT);
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP error! Status: ${response.status} ${errorText}`);
      }
      const data = await response.json();
      setProductGroups(data);
    } catch (e) {
      console.error("Failed to fetch product groups:", e);
      setError(
        e.message || "Failed to load product groups. Please try refreshing."
      );
    } finally {
      setIsLoading(false);
    }
  }, []);

  // useEffect to call fetchProductGroups when the component mounts
  useEffect(() => {
    fetchProductGroups();
  }, [fetchProductGroups]);

  const handleAddPGroup = async () => {
    if (newPGroupName.trim() === "") {
      setFormError("Product group name cannot be empty.");
      return;
    }

    setIsSubmitting(true);
    setFormError(null);
    setError(null);
    setSuccessMessage("");

    const groupData = {
      name: newPGroupName.trim(),
      // 'Id' is generated by the backend
    };

    try {
      const response = await fetch(API_PRODUCT_GROUPS_ENDPOINT, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(groupData),
      });

      if (!response.ok) {
        let errorMessage = `Error: ${response.status}`;
        try {
          const errorData = await response.json();
          if (errorData.errors && errorData.errors.Name) {
            // ASP.NET Core ModelState
            errorMessage = errorData.errors.Name.join(" ");
          } else if (errorData.title) {
            // ProblemDetails
            errorMessage = errorData.title;
          } else if (
            typeof errorData === "string" &&
            errorData.includes("already exists")
          ) {
            // Custom error string
            errorMessage = errorData;
          } else {
            errorMessage = response.statusText;
          }
        } catch (e) {
          errorMessage = response.statusText; // Fallback
        }
        throw new Error(errorMessage);
      }

      // const addedGroup = await response.json(); // Optional: use if needed
      setSuccessMessage("Product Group added successfully!");
      setNewPGroupName(""); // Clear input field
      fetchProductGroups(); // Refresh the list to show the newly added group
    } catch (e) {
      console.error("Failed to add product group:", e);
      setFormError(e.message || "Product Group Already Exists!");
    } finally {
      setIsSubmitting(false);
    }
  };

  const closeModal = () => {
    setSuccessMessage("");
    setFormError(""); // Also clear formError if it was shown in a modal
    setError(""); // Clear general error
  };

  return (
    <div className="pg-page-content">
      {/* Modals for success and form errors */}
      <MessageModal
        message={successMessage}
        onClose={closeModal}
        type="success"
      />
      <MessageModal message={formError} onClose={closeModal} type="error" />

      {/* Modal for general fetch error (if not a form error) */}
      {error && !formError && (
        <MessageModal message={error} onClose={closeModal} type="error" />
      )}

      <h1 className="pg-main-title">Products Group</h1>

      {isLoading && (
        <p className="pg-loading-message">Loading product groups...</p>
      )}
      {/* Display general fetch error if not loading and no form error is active */}
      {!isLoading && error && !formError && (
        <p className="pg-fetch-error-message">{error}</p>
      )}

      <div className="table-responsive-container">
        <table className="data-table">
          <thead>
            <tr>
              <th className="pg-th-serial">Serial No</th>
              <th className="pg-th-groupname">Products Group</th>
            </tr>
          </thead>
          <tbody>
            {!isLoading &&
              productGroups.length > 0 &&
              productGroups.map((group, index) => (
                <tr key={group.id}>
                  {/* Use backend 'id' for key */}
                  <td className="pg-td-serial">{index + 1}</td>
                  <td>{group.name}</td>
                </tr>
              ))}
            {!isLoading && productGroups.length === 0 && !error && (
              <tr>
                <td colSpan="2" className="no-data-cell">
                  No product groups found. Add one below.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>

      <div className="pg-create-section">
        <h3 className="pg-create-title">Create New Group</h3>
        {/* Form error can be displayed here or in modal */}
        {/* {formError && <p className="pg-form-error-message">{formError}</p>} */}
        <div className="pg-form-row">
          <label htmlFor="productGroupNameInput" className="pg-label">
            Products group :
          </label>
          <input
            type="text"
            id="productGroupNameInput"
            className="pg-input"
            value={newPGroupName}
            onChange={(e) => {
              setNewPGroupName(e.target.value);
              if (formError) setFormError(null); // Clear error on new input
            }}
            placeholder="Enter group name"
            disabled={isSubmitting}
          />
        </div>
        <button
          type="button"
          className="pg-add-button"
          onClick={handleAddPGroup}
          disabled={isSubmitting || isLoading} // Disable if loading list too
        >
          {isSubmitting ? "Adding..." : "Add"}
        </button>
      </div>
    </div>
  );
};

export default ProductsGroup;
