import React, { useState, useEffect, useCallback } from "react";
import "./UOM.css"; // Styles specific to this component
import { API_UOM_ENDPOINT } from "../../../config"; // Ensure this is correctly exported from config.js

// Simple Modal Component
const MessageModal = ({ message, onClose, type = "success" }) => {
  if (!message) return null;
  return (
    <div className="uom-modal-overlay">
      {" "}
      {/* Using uom- prefix */}
      <div className={`uom-modal-content ${type}`}>
        {" "}
        {/* Note: type adds 'success' or 'error' class */}
        <p>{message}</p>
        <button onClick={onClose} className="uom-modal-close-button">
          OK
        </button>
      </div>
    </div>
  );
};

const UOM = () => {
  const [uoms, setUoms] = useState([]);
  const [newUomName, setNewUomName] = useState("");

  const [isLoading, setIsLoading] = useState(false); // For fetching list
  const [isSubmitting, setIsSubmitting] = useState(false); // For adding new UOM
  const [error, setError] = useState(null); // For general fetch/post errors
  const [formError, setFormError] = useState(null); // For form-specific validation errors from backend
  const [successMessage, setSuccessMessage] = useState("");

  // Fetch UOMs from the backend
  const fetchUoms = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(API_UOM_ENDPOINT); // Using new endpoint
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP error! Status: ${response.status} ${errorText}`);
      }
      const data = await response.json();
      setUoms(data);
    } catch (e) {
      console.error("Failed to fetch UOMs:", e);
      setError(e.message || "Failed to load UOMs. Please try refreshing.");
    } finally {
      setIsLoading(false);
    }
  }, []); // API_UOM_ENDPOINT is a constant, so not needed in deps if imported directly

  // useEffect to call fetchUoms when the component mounts
  useEffect(() => {
    fetchUoms();
  }, [fetchUoms]);

  const handleAddUom = async () => {
    if (newUomName.trim() === "") {
      setFormError("UOM name cannot be empty.");
      return;
    }

    setIsSubmitting(true);
    setFormError(null);
    setError(null);
    setSuccessMessage("");

    const uomData = {
      name: newUomName.trim(),
      // 'Id' is typically generated by the backend for new entities
    };

    try {
      const response = await fetch(API_UOM_ENDPOINT, {
        // Using new endpoint
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(uomData),
      });

      if (!response.ok) {
        let errorMessage = `Error: ${response.status}`;
        try {
          const errorData = await response.json();
          // Adjust error parsing based on your UOM API's error response structure
          if (errorData.errors && errorData.errors.Name) {
            // Example: ASP.NET Core ModelState
            errorMessage = errorData.errors.Name.join(" ");
          } else if (errorData.title) {
            // Example: ProblemDetails
            errorMessage = errorData.title;
          } else if (
            typeof errorData === "string" &&
            errorData.includes("already exists") // Example specific error string from backend
          ) {
            errorMessage = errorData;
          } else if (typeof errorData === "string" && errorData.trim() !== "") {
            // Plain string error
            errorMessage = errorData;
          } else {
            errorMessage =
              response.statusText ||
              `Request failed with status ${response.status}`;
          }
        } catch (e) {
          // If response.json() fails or no specific error structure found
          errorMessage =
            response.statusText ||
            `Request failed with status ${response.status}`;
        }
        throw new Error(errorMessage);
      }

      // const addedUom = await response.json(); // Optional: if your POST returns the created object and you need it
      setSuccessMessage("UOM added successfully!");
      setNewUomName(""); // Clear input field
      fetchUoms(); // Refresh the list to show the newly added UOM
    } catch (e) {
      console.error("Failed to add UOM:", e);
      setFormError(
        e.message || "UOM Already Exists or another error occurred!"
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  const closeModal = () => {
    setSuccessMessage("");
    setFormError("");
    setError("");
  };

  return (
    <div className="uom-page-content">
      {" "}
      {/* uom- prefix */}
      {/* Modals for success and form errors */}
      <MessageModal
        message={successMessage}
        onClose={closeModal}
        type="success"
      />
      <MessageModal message={formError} onClose={closeModal} type="error" />
      {/* Modal for general fetch error (if not a form error) */}
      {error &&
        !formError && ( // Only show general error if no specific form error is active
          <MessageModal message={error} onClose={closeModal} type="error" />
        )}
      <h1 className="uom-main-title">Units of Measure (UOM)</h1>{" "}
      {/* Changed title */}
      {isLoading && <p className="uom-loading-message">Loading UOMs...</p>}
      {/* Display general fetch error if not loading and no form error is active */}
      {!isLoading &&
        error &&
        !formError && ( // Condition to show general fetch error
          <p className="uom-fetch-error-message">{error}</p>
        )}
      <div className="table-responsive-container">
        <table className="data-table">
          <thead>
            <tr>
              <th className="uom-th-serial">Serial No</th>
              <th className="uom-th-uomname">UOM Name</th>{" "}
              {/* Changed header */}
            </tr>
          </thead>
          <tbody>
            {!isLoading &&
              uoms.length > 0 &&
              uoms.map((uom, index) => (
                <tr key={uom.id}>
                  {" "}
                  {/* Assuming UOM objects have an 'id' property */}
                  <td className="uom-td-serial">{index + 1}</td>
                  <td>{uom.name}</td>
                </tr>
              ))}
            {!isLoading && uoms.length === 0 && !error && (
              <tr>
                <td colSpan="2" className="no-data-cell">
                  No UOMs found. Add one below.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
      <div className="uom-create-section">
        <h3 className="uom-create-title">Create New UOM</h3>{" "}
        {/* Changed title */}
        <div className="uom-form-row">
          <label htmlFor="uomNameInput" className="uom-label">
            UOM Name : {/* Changed label */}
          </label>
          <input
            type="text"
            id="uomNameInput"
            className="uom-input"
            value={newUomName}
            onChange={(e) => {
              setNewUomName(e.target.value);
              if (formError) setFormError(null); // Clear form error on new input
            }}
            placeholder="Enter UOM name (e.g., Piece, Kg, Box)" // Changed placeholder
            disabled={isSubmitting}
          />
        </div>
        <button
          type="button"
          className="uom-add-button"
          onClick={handleAddUom}
          disabled={isSubmitting || isLoading} // Disable if loading list too
        >
          {isSubmitting ? "Adding..." : "Add"}
        </button>
      </div>
    </div>
  );
};

export default UOM;
